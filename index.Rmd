---
title: "Confidence Intervals for Variances from lm"
author: "Kevin"
date: "Friday, April 03, 2015"
output: 
  html_document:
    theme: cerulean
---

<a href="https://github.com/kferris10/CIs-for-lm-variances"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a>

```{r knitr-setup, echo=FALSE, warning=FALSE, message=FALSE, cache=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      message = FALSE, 
                      warning = FALSE, 
                      tidy = FALSE, 
                      fig.height = 4, 
                      fig.width = 6, 
                      fig.align = "center", 
                      size = "small", 
                      digits = 3, 
                      comment = "#>")
options(show.signif.stars = F, 
        digits = 3)
set.seed(42)
```


## Very Quick Example

Simulated 95% confidence interval for the residual standard error from an `lm` model for the mtcars dataset.

```{r mtcars_sim}
m1 <- lm(mpg ~ wt, data = mtcars)
library(arm)
sims <- sim(m1, 1000)
quantile(sims@sigma, probs = c(.025, .975))
```

## The Linear Model

The following linear model can be fit in R with the `lm` function.

$mpg_i = \beta_{0} + \beta_{1} wt_{i} + \epsilon_{i}$

$\epsilon_i \sim N(0, \sigma^2)$

```{r mtcars_lm}
m2 <- lm(mpg ~ wt, data = mtcars)
summary(m2)
```

In this model, there are three parameters: $\beta_0$, $\beta_1$, and $\sigma$.  R estimates these parameters as 37.3, -5.3, and 3.0 respectively.  

## The `sim` function

The `arm` package was written by Andrew Gelman and Yu-Song Su to complement Gelman's *Data Analysis Using Regression and Multilevel/Hierarchical
Models* book.  In Chapter 7 of this book, they discuss how to use simulation for inferences in regression context.

To aid with these inferences, they provided the `sim` function in the package.  This function simulates estimated parameters from the fitted model.  In the code below, I simulate $\beta_0$, $\beta_1$, and $\sigma$ 1000 times.  The `str` command reveals the structure of an R object.  We can see that the simulated values are stored in two separate parts of the `sims` object.  The estimated regression coefficients ($\beta_0$ and $\beta_1$) are stored in a matrix named `coef`, and the estimated variabilities (just $\sigma$ in this example) are named `sigma`.

```{r lm_sims}
library(arm)
sims <- sim(m2, 1000)
str(sims)
```

## Confidence Intervals for $\sigma$

These simulations can be used to provide a summary of the model's suggested values of the parameters.

```{r sims_summary}
summary(sims@sigma) ## the @ sign is used because sim uses S4 class objects
```

We can visualize the distribution of simulated values.

```{r sims_density}
library(ggplot2)
qplot(sims@sigma, geom = "density", fill = I("lightblue")) + 
  labs(x = expression(sigma), 
       title = "Simulated Distribution of Residual Standard Error")
```

To generate a confidence interval for $\sigma$, we can just extract the middle 95% of this distribution using the `quantile` function.

```{r sims_ci}
quantile(sims@sigma, probs = c(.025, .975))
```

## CIs for Multilevel Models Using `lm`

```{r sim_tree_data, echo=FALSE}
library(dplyr)

# variability at each level
sigma_site <- runif(1, 0, 1)
sigma_plot <- runif(1, 0, 1)
sigma_tree <- runif(1, 0, 1)
sigma_core <- runif(1, 0, 1)
sigma_e <- runif(1, 0, 1)

# LEF   ------------------------------------------------

# number of observations at each level
n_sites <- 4
n_plots <- 2
n_trees <- 6
n_cores <- 1
n_obs <- prod(n_sites, n_plots, n_trees, n_cores)

# simulating data
lef <- data_frame(
  location = "LEF", 
  site = paste0("S", rep(1:n_sites, each = n_obs / n_sites)), 
  plot = paste0("P", rep(rep(1:n_plots, each = n_obs / (n_sites * n_plots)), 
                         times = n_sites)), 
  tree = paste0("T", rep(rep(1:n_trees, each = n_obs / (n_sites * n_plots * n_trees)), 
                         times = n_sites * n_plots)), 
  core = paste0("C", rep(rep(1:n_cores, each = n_obs / (n_sites * n_plots * n_trees * n_cores)))), 
  species = ifelse(substr(tree, 2, 2) <= 3, "DF", 
                   ifelse(site == "S1", "WL", 
                          ifelse(site == "S2", "PP", 
                                 ifelse(site == "S3", "EB", 
                                        "DR")))), 
  elevation = ifelse(site %in% c("S1", "S2"), "H", "L"), 
  aspect = ifelse(site %in% c("S1", "S3"), "N", "S"), 
  topo = ifelse(plot == "P1", "valley", "slope")
) %>% 
  mutate(int = rnorm(1, 3, .5)) %>% 
  group_by(site) %>% 
  mutate(b_site = rnorm(1, 0, sigma_site)) %>% 
  group_by(site, plot) %>% 
  mutate(b_plot = rnorm(1, 0, sigma_plot)) %>% 
  group_by(site, plot, tree) %>% 
  mutate(b_tree = rnorm(1, 0, sigma_tree)) %>% 
  group_by(site, plot, tree, core) %>% 
  mutate(b_core = rnorm(1, 0, sigma_core)) %>% 
  ungroup() %>% 
  mutate(epsilon = rnorm(n(), 0, sigma_e), 
         m_c = int + b_site + b_plot + b_tree + b_core + epsilon)

# BZN ---------------------------------------------------

n_sites <- 2
n_plots <- 2
n_trees <- 4
n_cores <- 4
n_obs <- prod(n_sites, n_plots, n_trees, n_cores)

bzn <- data_frame(
  location = "BZN", 
  site = paste0("S", rep(1:n_sites, each = n_obs / n_sites)), 
  plot = paste0("P", rep(rep(1:n_plots, each = n_obs / (n_sites * n_plots)), 
                         times = n_sites)), 
  tree = paste0("T", rep(rep(1:n_trees, each = n_obs / (n_sites * n_plots * n_trees)), 
                         times = n_sites * n_plots)), 
  core = paste0("C", rep(rep(1:n_cores, each = n_obs / (n_sites * n_plots * n_trees * n_cores)), 
                         times = n_sites * n_plots * n_trees)), 
  species = "DF", 
  elevation = ifelse(site %in% c("S1", "S2"), "H", "L"), 
  aspect = ifelse(site %in% c("S1", "S3"), "N", "S"), 
  canopy = ifelse(plot == "P1", "open", "closed")
)  %>% 
  mutate(int = rnorm(1, 3, .5)) %>% 
  group_by(site) %>% 
  mutate(b_site = rnorm(1, 0, sigma_site)) %>% 
  group_by(site, plot) %>% 
  mutate(b_plot = rnorm(1, 0, sigma_plot)) %>% 
  group_by(site, plot, tree) %>% 
  mutate(b_tree = rnorm(1, 0, sigma_tree)) %>% 
  group_by(site, plot, tree, core) %>% 
  mutate(b_core = rnorm(1, 0, sigma_core)) %>% 
  ungroup() %>% 
  mutate(epsilon = rnorm(n(), 0, sigma_e), 
         m_c = int + b_site + b_plot + b_tree + b_core + epsilon)

# for each level ------------------------------------------
tree_data <- bind_rows(bzn, lef) %>% 
  filter(species == "DF")            ## only Douglas Firs

# core level
by_core <- tree_data %>% 
  group_by(location, site, plot, tree, core) %>% 
  summarise(m_c = mean(m_c))
# tree level
by_tree <- tree_data %>% 
  group_by(location, site, plot, tree) %>% 
  summarise(m_c = mean(m_c))
# plot level
by_plot <- tree_data %>% 
  group_by(location, site, plot) %>% 
  summarise(m_c = mean(m_c))
# site level
by_site <- tree_data %>% 
  group_by(location, site) %>% 
  summarise(m_c = mean(m_c))
```

Estimated 95% confidence intervals

```{r mods_cis}
# models by level
mod_core <- lm(m_c ~ location * site * plot * tree, data = by_core)
mod_tree <- lm(m_c ~ location * site * plot, data = by_tree)
mod_plot <- lm(m_c ~ location * site, data = by_plot)
mod_site <- lm(m_c ~ location, data = by_site)
# simulating RSE at each level
sim_sigmas <- sapply(list(mod_core, mod_tree, mod_plot, mod_site), function(x) {
  sim(x, 500)@sigma
})
# calculating CIs
apply(sim_sigmas, 2, quantile, probs = c(.025, .975)) %>% 
  data.frame() %>% 
  setNames(c("CoreLevel", "TreeLevel", "PlotLevel", "SiteLevel"))
```

Comparing using `ggvis`

```{r mods_densities}
# turn simulations into long format
library(tidyr)  ## to go to long format
sim_sigmas_df <- sim_sigmas %>% 
  data.frame() %>%   ## have to for tidyr
  setNames(c("core_sd", "tree_sd", "plot_sd", "site_sd")) %>% 
  gather(level, sigma)
# density plots
library(ggvis)
sim_sigmas_df %>% 
  ggvis(~sigma, fill = ~level) %>% 
  group_by(level) %>% 
  layer_densities()
```

Comparing to an `lmer` model

```{r lmer_model}
library(lme4)
m3 <- lmer(m_c ~ (1 | location/site/plot/tree), data = tree_data)
confint(m3)
```


## Code to Simulate Data

```{r sim_tree_data, echo=TRUE, eval=FALSE}
```




